<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Marshall Ward">
  <meta name="dcterms.date" content="2022-10-18">
  <title>MOM6 Internals</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="./reveal.js/dist/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="./reveal.js/css/theme/gfdl.css" id="theme">
  <!-- Explicitly add zenburn for highlight support -->
  <link rel="stylesheet" href="./reveal.js/plugin/highlight/zenburn.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? './reveal.js/css/print/pdf.scss' : './reveal.js/css/print/paper.scss';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="./reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
  <base href="./index.html">
</head>
<body>
  <div class="reveal"
       style="background: url(img/bg_gfdl.jpg);
              background-size: cover;">

    <header style="width: 10vh; position: absolute; bottom: 2vh; right: 2vh;">
      <img src="img/noaa_logo.png">
    </header>

    <footer style="font-size: 1pc; position: absolute; bottom: 2%; left: 2%;">
      <code><p><a href="https://marshallward.org/mom6workshop/internals.html">https://marshallward.org/mom6workshop/internals.html</a></p></code>
    </footer>

    <div class="slides">

<section id="title-slide">
  <!--div class="reveal" style="text-align: right;">
    <img src="img/noaa_logo.png"
         style="background: none; border: none; box-shadow: none;
         width: 30%"
         alt="NCI">
  </div-->
  <h1 class="title">MOM6 Internals</h1>
  <p class="author" style="text-align: right;">Marshall Ward</p>
  <p class="date" style="text-align: right;">2022-10-18</p>
  <!-- Currently cannot add notes to a title slide, so have to do manually-->
  <aside class="notes">
    <p>TODO</p>
  </aside>
</section>

<section id="mom6-directory-tree" class="title-slide slide level1">
<h1>MOM6 directory tree</h1>
<table>
<thead>
<tr class="header">
<th>Directory</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>src/</code></td>
<td>Model code, including solvers</td>
</tr>
<tr class="even">
<td><code>config_src/</code></td>
<td>Configurable components</td>
</tr>
<tr class="odd">
<td><code>pkg/</code></td>
<td>Dependencies linked into <code>src/</code></td>
</tr>
<tr class="even">
<td><code>doc/</code></td>
<td>Documentation</td>
</tr>
<tr class="odd">
<td><code>ac/</code></td>
<td>Autoconf build</td>
</tr>
</tbody>
</table>
</section>

<section id="configuration-code" class="title-slide slide level1">
<h1>Configuration Code</h1>
<ul>
<li>drivers</li>
<li>memory layout (symmetrics/nonsymmetric)</li>
<li>framework (infra/FMS1,FMS2)</li>
<li><dl>
<dt>externals</dt>
<dd><ul>
<li>biogeochemical model</li>
<li>Data assimilation (ODA)</li>
<li>database interface</li>
<li>Python interface?</li>
</ul>
</dd>
</dl></li>
</ul>
</section>

<section id="src" class="title-slide slide level1">
<h1><code>src/</code></h1>
<table>
<thead>
<tr class="header">
<th>Directory</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>core/</code></td>
<td>Init, Timestep, main solvers</td>
</tr>
<tr class="even">
<td><code>parameterizations/</code></td>
<td>Viscosity, mixing, diabatic</td>
</tr>
<tr class="odd">
<td><code>tracer/</code></td>
<td>Tracer dynamics</td>
</tr>
<tr class="even">
<td><code>ALE/</code></td>
<td>Vertical remapping</td>
</tr>
<tr class="odd">
<td><code>diagnostics/</code></td>
<td>Diagonostic management</td>
</tr>
<tr class="even">
<td><code>user/</code></td>
<td>Preset forcing, topography</td>
</tr>
</tbody>
</table>
<p>Also see <code>framework/</code>, <code>equation_of_state/</code>, etc</p>
</section>

<section id="module-format" class="title-slide slide level1">
<h1>Module Format</h1>
<pre class="fortran" data-code="fortran

"><code>!&gt; Implemented geothermal heating at the ocean bottom.
module MOM_geothermal

! This file is part of MOM6. See LICENSE.md for the license.

use MOM_diag_mediator, only : post_data, register_diag_field, safe_alloc_alloc
use MOM_diag_mediator, only : register_static_field, time_type, diag_ctrl
use MOM_domains,       only : pass_var
use MOM_error_handler, only : MOM_error, FATAL, WARNING
use MOM_file_parser,   only : get_param, log_param, log_version, param_file_type
use MOM_io,            only : MOM_read_data, slasher
use MOM_grid,          only : ocean_grid_type
use MOM_unit_scaling,  only : unit_scale_type
use MOM_variables,     only : thermo_var_ptrs
use MOM_verticalGrid,  only : verticalGrid_type, get_thickness_units
use MOM_EOS,           only : calculate_density, calculate_density_derivs

implicit none ; private

#include &lt;MOM_memory.h&gt;

public geothermal_entraining, geothermal_in_place, geothermal_init, geothermal_end

!&gt; Control structure for geothermal heating
type, public :: geothermal_CS ; private
  logical :: initialized = .false. !&lt; True if this control structure has been initialized.
  real    :: dRcv_dT_inplace  !&lt; The value of dRcv_dT above which (dRcv_dT is negative) the
                              !! water is heated in place instead of moving upward between
                              !! layers in non-ALE layered mode [R C-1 ~&gt; kg m-3 degC-1]
  real, allocatable, dimension(:,:) :: geo_heat !&lt; The geothermal heat flux [Q R Z T-1 ~&gt; W m-2]
  real    :: geothermal_thick !&lt; The thickness over which geothermal heating is
                              !! applied [H ~&gt; m or kg m-2]
  logical :: apply_geothermal !&lt; If true, geothermal heating will be applied.  This is false if
                              !! GEOTHERMAL_SCALE is 0 and there is no heat to apply.

  type(time_type), pointer :: Time =&gt; NULL() !&lt; A pointer to the ocean model&#39;s clock
  type(diag_ctrl), pointer :: diag =&gt; NULL() !&lt; A structure that is used to regulate the timing
                                             !! timing of diagnostic output
  integer :: id_internal_heat_heat_tendency = -1  !&lt; ID for diagnostic of heat tendency
  integer :: id_internal_heat_temp_tendency = -1  !&lt; ID for diagnostic of temperature tendency
  integer :: id_internal_heat_h_tendency = -1     !&lt; ID for diagnostic of thickness tendency

end type geothermal_CS

contains

!&gt; Applies geothermal heating, including the movement of water
!! between isopycnal layers to match the target densities.  The heating is
!! applied to the bottommost layers that occur within GEOTHERMAL_THICKNESS of the bottom. If
!! the partial derivative of the coordinate density with temperature is positive
!! or very small, the layers are simply heated in place.  Any heat that can not
!! be applied to the ocean is returned (WHERE)?
subroutine geothermal_entraining(h, tv, dt, ea, eb, G, GV, US, CS, halo)
  type(ocean_grid_type),                     intent(inout) :: G  !&lt; The ocean&#39;s grid structure.
  type(verticalGrid_type),                   intent(in)    :: GV !&lt; The ocean&#39;s vertical grid structure.
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)), intent(inout) :: h  !&lt; Layer thicknesses [H ~&gt; m or kg m-2]
  type(thermo_var_ptrs),                     intent(inout) :: tv !&lt; A structure containing pointers
                                                                 !! to any available thermodynamic fields.
  real,                                      intent(in)    :: dt !&lt; Time increment [T ~&gt; s].
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)), intent(inout) :: ea !&lt; The amount of fluid moved
                                                                 !! downward into a layer; this
                                                                 !! should be increased due to mixed
                                                                 !! layer detrainment [H ~&gt; m or kg m-2]
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)), intent(inout) :: eb !&lt; The amount of fluid moved upward
                                                                 !! into a layer; this should be
                                                                 !! increased due to mixed layer
                                                                 !! entrainment [H ~&gt; m or kg m-2].
  type(unit_scale_type),                     intent(in)    :: US !&lt; A dimensional unit scaling type
  type(geothermal_CS),                       intent(in)    :: CS !&lt; The control structure returned by
                                                                 !! a previous call to
                                                                 !! geothermal_init.
  integer,                         optional, intent(in)    :: halo !&lt; Halo width over which to work
  ! Local variables
  real, dimension(SZI_(G)) :: &amp;
    heat_rem,  &amp; ! remaining heat [H C ~&gt; m degC or kg degC m-2]
    h_geo_rem, &amp; ! remaining thickness to apply geothermal heating [H ~&gt; m or kg m-2]
    Rcv_BL,    &amp; ! coordinate density in the deepest variable density layer [R ~&gt; kg m-3]
    p_ref        ! coordinate densities reference pressure [R L2 T-2 ~&gt; Pa]

  real, dimension(2) :: &amp;
    T2, S2, &amp;   ! temp and saln in the present and target layers [C ~&gt; degC] and [S ~&gt; ppt]
    dRcv_dT_, &amp; ! partial derivative of coordinate density wrt temp [R C-1 ~&gt; kg m-3 degC-1]
    dRcv_dS_    ! partial derivative of coordinate density wrt saln [R S-1 ~&gt; kg m-3 ppt-1]

  real :: Angstrom, H_neglect  ! small thicknesses [H ~&gt; m or kg m-2]
  real :: Rcv           ! coordinate density of present layer [R ~&gt; kg m-3]
  real :: Rcv_tgt       ! coordinate density of target layer [R ~&gt; kg m-3]
  real :: dRcv          ! difference between Rcv and Rcv_tgt [R ~&gt; kg m-3]
  real :: dRcv_dT       ! partial derivative of coordinate density wrt temp
                        ! in the present layer [R C-1 ~&gt; kg m-3 degC-1]; usually negative
  real :: h_heated      ! thickness that is being heated [H ~&gt; m or kg m-2]
  real :: heat_avail    ! heating available for the present layer [C H ~&gt; degC m or degC kg m-2]
  real :: heat_in_place ! heating to warm present layer w/o movement between layers
                        ! [C H ~&gt; degC m or degC kg m-2]
  real :: heat_trans    ! heating available to move water from present layer to target
                        ! layer [C H ~&gt; degC m or degC kg m-2]
  real :: heating       ! heating used to move water from present layer to target layer
                        ! [C H ~&gt; degC m or degC kg m-2]
                        ! 0 &lt;= heating &lt;= heat_trans
  real :: h_transfer    ! thickness moved between layers [H ~&gt; m or kg m-2]
  real :: wt_in_place   ! relative weighting that goes from 0 to 1 [nondim]
  real :: I_h           ! inverse thickness [H-1 ~&gt; m-1 or m2 kg-1]
  real :: dTemp         ! temperature increase in a layer [C ~&gt; degC]
  real :: Irho_cp       ! inverse of heat capacity per unit layer volume
                        ! [C H Q-1 R-1 Z-1 ~&gt; degC m3 J-1 or degC kg J-1]

  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)) :: &amp;
    T_old, &amp; ! Temperature of each layer before any heat is added, for diagnostics [C ~&gt; degC]
    h_old, &amp; ! Thickness of each layer before any heat is added, for diagnostics [H ~&gt; m or kg m-2]
    work_3d ! Scratch variable used to calculate changes due to geothermal
  real :: Idt           ! inverse of the timestep [T-1 ~&gt; s-1]

  logical :: do_i(SZI_(G))
  logical :: compute_h_old, compute_T_old
  integer :: i, j, k, is, ie, js, je, nz, k2
  integer :: isj, iej, num_left, nkmb, k_tgt

  is = G%isc ; ie = G%iec ; js = G%jsc ; je = G%jec ; nz = GV%ke
  if (present(halo)) then
    is = G%isc-halo ; ie = G%iec+halo ; js = G%jsc-halo ; je = G%jec+halo
  endif

  if (.not. CS%initialized) call MOM_error(FATAL, &quot;MOM_geothermal: &quot;//&amp;
         &quot;Module must be initialized before it is used.&quot;)
  if (.not.CS%apply_geothermal) return

  nkmb      = GV%nk_rho_varies
  Irho_cp   = 1.0 / (GV%H_to_RZ * tv%C_p)
  Angstrom  = GV%Angstrom_H
  H_neglect = GV%H_subroundoff
  p_ref(:)  = tv%P_Ref
  Idt       = 1.0 / dt

  if (.not.associated(tv%T)) call MOM_error(FATAL, &quot;MOM geothermal_entraining: &quot;//&amp;
      &quot;Geothermal heating can only be applied if T &amp; S are state variables.&quot;)

!  do j=js,je ; do i=is,ie
!    resid(i,j) = tv%internal_heat(i,j)
!  enddo ; enddo

  ! Conditionals for tracking diagnostic depdendencies
  compute_h_old = CS%id_internal_heat_h_tendency &gt; 0 &amp;
                  .or. CS%id_internal_heat_heat_tendency &gt; 0 &amp;
                  .or. CS%id_internal_heat_temp_tendency &gt; 0

  compute_T_old = CS%id_internal_heat_heat_tendency &gt; 0 &amp;
                  .or. CS%id_internal_heat_temp_tendency &gt; 0

  if (CS%id_internal_heat_heat_tendency &gt; 0) work_3d(:,:,:) = 0.0

  if (compute_h_old .or. compute_T_old) then ; do k=1,nz ; do j=js,je ; do i=is,ie
    ! Save temperature and thickness before any changes are made (for diagnostics)
    h_old(i,j,k) = h(i,j,k)
    T_old(i,j,k) = tv%T(i,j,k)
  enddo ; enddo ; enddo ; endif

!$OMP parallel do default(none) shared(is,ie,js,je,G,GV,US,CS,dt,Irho_cp,nkmb,tv, &amp;
!$OMP                                  p_Ref,h,Angstrom,nz,H_neglect,eb,          &amp;
!$OMP                                  h_old,T_old,work_3d,Idt)                   &amp;
!$OMP                          private(heat_rem,do_i,h_geo_rem,num_left,          &amp;
!$OMP                                  isj,iej,Rcv_BL,h_heated,heat_avail,k_tgt,  &amp;
!$OMP                                  Rcv_tgt,Rcv,dRcv_dT,T2,S2,dRcv_dT_,        &amp;
!$OMP                                  dRcv_dS_,heat_in_place,heat_trans,         &amp;
!$OMP                                  wt_in_place,dTemp,dRcv,h_transfer,heating, &amp;
!$OMP                                  I_h)

  do j=js,je
    ! 1. Only work on columns that are being heated.
    ! 2. Find the deepest layer with any mass.
    ! 3. Find the partial derivative of locally referenced potential density
    !  and coordinate density with temperature, and the density of the layer
    !  and the layer above.
    ! 4. Heat a portion of the bottommost layer until it matches the target
    !    density of the layer above, and move it.
    ! 4a. In the case of variable density layers, heat but do not move.
    ! 5. If there is still heat left over, repeat for the next layer up.
    ! This subroutine updates thickness, T &amp; S, and increments eb accordingly.

    ! 6. If there is not enough mass in the ocean, pass some of the heat up
    !    from the ocean via the frazil field?

    num_left = 0
    do i=is,ie
      heat_rem(i) = G%mask2dT(i,j) * (CS%geo_heat(i,j) * (dt*Irho_cp))
      do_i(i) = .true. ; if (heat_rem(i) &lt;= 0.0) do_i(i) = .false.
      if (do_i(i)) num_left = num_left + 1
      h_geo_rem(i) = CS%Geothermal_thick
    enddo
    if (num_left == 0) cycle

    ! Find the first and last columns that need to be worked on.
    isj = ie+1 ; do i=is,ie ; if (do_i(i)) then ; isj = i ; exit ; endif ; enddo
    iej = is-1 ; do i=ie,is,-1 ; if (do_i(i)) then ; iej = i ; exit ; endif ; enddo

    if (nkmb &gt; 0) then
      call calculate_density(tv%T(:,j,nkmb), tv%S(:,j,nkmb), p_Ref(:), Rcv_BL(:), &amp;
                             tv%eqn_of_state, (/isj-(G%isd-1),iej-(G%isd-1)/) )
    else
      Rcv_BL(:) = -1.0
    endif

    do k=nz,1,-1
      do i=isj,iej ; if (do_i(i)) then

        if (h(i,j,k) &gt; Angstrom) then
          if ((h(i,j,k)-Angstrom) &gt;= h_geo_rem(i)) then
            h_heated = h_geo_rem(i)
            heat_avail = heat_rem(i)
            h_geo_rem(i) = 0.0
          else
            h_heated = (h(i,j,k)-Angstrom)
            heat_avail = heat_rem(i) * (h_heated / &amp;
                                        (h_geo_rem(i) + H_neglect))
            h_geo_rem(i) = h_geo_rem(i) - h_heated
          endif

          if (k&lt;=nkmb .or. nkmb&lt;=0) then
            ! Simply heat the layer; convective adjustment occurs later
            ! if necessary.
            k_tgt = k
          elseif ((k==nkmb+1) .or. (GV%Rlay(k-1) &lt; Rcv_BL(i))) then
            ! Add enough heat to match the lowest buffer layer density.
            k_tgt = nkmb
            Rcv_tgt = Rcv_BL(i)
          else
            ! Add enough heat to match the target density of layer k-1.
            k_tgt = k-1
            Rcv_tgt = GV%Rlay(k-1)
          endif

          if (k&lt;=nkmb .or. nkmb&lt;=0) then
            Rcv = 0.0 ; dRcv_dT = 0.0 ! Is this OK?
          else
            call calculate_density(tv%T(i,j,k), tv%S(i,j,k), tv%P_Ref, &amp;
                         Rcv, tv%eqn_of_state)
            T2(1) = tv%T(i,j,k) ; S2(1) = tv%S(i,j,k)
            T2(2) = tv%T(i,j,k_tgt) ; S2(2) = tv%S(i,j,k_tgt)
            call calculate_density_derivs(T2(:), S2(:), p_Ref(:), dRcv_dT_, dRcv_dS_, &amp;
                         tv%eqn_of_state, (/1,2/) )
            dRcv_dT = 0.5*(dRcv_dT_(1) + dRcv_dT_(2))
          endif

          if ((dRcv_dT &gt;= 0.0) .or. (k&lt;=nkmb .or. nkmb&lt;=0)) then
            ! This applies to variable density layers.
            heat_in_place = heat_avail
            heat_trans = 0.0
          elseif (dRcv_dT &lt;= CS%dRcv_dT_inplace) then
            ! This is the option that usually applies in isopycnal coordinates.
            heat_in_place = min(heat_avail, max(0.0, h(i,j,k) * &amp;
                                            ((GV%Rlay(k)-Rcv) / dRcv_dT)))
            heat_trans = heat_avail - heat_in_place
          else
            ! wt_in_place should go from 0 to 1.
            wt_in_place = (CS%dRcv_dT_inplace - dRcv_dT) / CS%dRcv_dT_inplace
            heat_in_place = max(wt_in_place*heat_avail, &amp;
                                h(i,j,k) * ((GV%Rlay(k)-Rcv) / dRcv_dT) )
            heat_trans = heat_avail - heat_in_place
          endif

          if (heat_in_place &gt; 0.0) then
            ! This applies to variable density layers. In isopycnal coordinates
            ! this only arises for relatively fresh water near the freezing
            ! point, in which case heating in place will eventually cause things
            ! to sort themselves out, if only because the water will warm to
            ! the temperature of maximum density.
            dTemp = heat_in_place / (h(i,j,k) + H_neglect)
            tv%T(i,j,k) = tv%T(i,j,k) + dTemp
            heat_rem(i) = heat_rem(i) - heat_in_place
            Rcv = Rcv + dRcv_dT * dTemp
          endif

          if (heat_trans &gt; 0.0) then
            ! The second expression might never be used, but will avoid
            ! division by 0.
            dRcv = max(Rcv - Rcv_tgt, 0.0)

            !   dTemp = -dRcv / dRcv_dT
            !   h_transfer = min(heat_rem(i) / dTemp, h(i,j,k)-Angstrom)
            if ((-dRcv_dT * heat_trans) &gt;= dRcv * (h(i,j,k)-Angstrom)) then
              h_transfer = h(i,j,k) - Angstrom
              heating = (h_transfer * dRcv) / (-dRcv_dT)
              ! Since not all the heat has been applied, return the fraction
              ! of the layer thickness that has not yet been fully heated to
              ! the h_geo_rem.
              h_geo_rem(i) = h_geo_rem(i) + h_heated * &amp;
                      ((heat_avail - (heating + heat_in_place)) / heat_avail)
            else
              h_transfer = (-dRcv_dT * heat_trans) / dRcv
              heating = heat_trans
            endif
            heat_rem(i) = heat_rem(i) - heating

            I_h = 1.0 / ((h(i,j,k_tgt) + H_neglect) + h_transfer)
            tv%T(i,j,k_tgt) = ((h(i,j,k_tgt) + H_neglect) * tv%T(i,j,k_tgt) + &amp;
                               (h_transfer * tv%T(i,j,k) + heating)) * I_h
            tv%S(i,j,k_tgt) = ((h(i,j,k_tgt) + H_neglect) * tv%S(i,j,k_tgt) + &amp;
                               h_transfer * tv%S(i,j,k)) * I_h

            h(i,j,k) = h(i,j,k) - h_transfer
            h(i,j,k_tgt) = h(i,j,k_tgt) + h_transfer
            eb(i,j,k_tgt) = eb(i,j,k_tgt) + h_transfer
            if (k_tgt &lt; k-1) then
              do k2 = k_tgt+1,k-1
                eb(i,j,k2) = eb(i,j,k2) + h_transfer
              enddo
            endif
          endif

          if (heat_rem(i) &lt;= 0.0) then
            do_i(i) = .false. ; num_left = num_left-1
            ! For efficiency, uncomment these?
            ! if ((i==isj) .and. (num_left &gt; 0)) then ; do i2=isj+1,iej ; if (do_i(i2)) then
            !   isj = i2 ; exit ! Set the new starting value.
            ! endif ; enddo ; endif
            ! if ((i==iej) .and. (num_left &gt; 0)) then ; do i2=iej-1,isj,-1 ; if (do_i(i2)) then
            !   iej = i2 ; exit ! Set the new ending value.
            ! endif ; enddo ; endif
          endif
        endif

        ! Calculate heat tendency due to addition and transfer of internal heat
        if (CS%id_internal_heat_heat_tendency &gt; 0) then
          work_3d(i,j,k) = ((GV%H_to_RZ*tv%C_p) * Idt) * (h(i,j,k) * tv%T(i,j,k) - h_old(i,j,k) * T_old(i,j,k))
        endif

      endif ; enddo
      if (num_left &lt;= 0) exit
    enddo ! k-loop

    if (associated(tv%internal_heat)) then ; do i=is,ie
      tv%internal_heat(i,j) = tv%internal_heat(i,j) + GV%H_to_RZ * &amp;
           (G%mask2dT(i,j) * (CS%geo_heat(i,j) * (dt*Irho_cp)) - heat_rem(i))
    enddo ; endif
  enddo ! j-loop

  ! Post diagnostic of 3D tendencies (heat, temperature, and thickness) due to internal heat
  if (CS%id_internal_heat_heat_tendency &gt; 0) then
    call post_data(CS%id_internal_heat_heat_tendency, work_3d, CS%diag, alt_h=h_old)
  endif
  if (CS%id_internal_heat_temp_tendency &gt; 0) then
    do k=1,nz ; do j=js,je ; do i=is,ie
      work_3d(i,j,k) = Idt * (tv%T(i,j,k) - T_old(i,j,k))
    enddo ; enddo ; enddo
    call post_data(CS%id_internal_heat_temp_tendency, work_3d, CS%diag, alt_h=h_old)
  endif
  if (CS%id_internal_heat_h_tendency &gt; 0) then
    do k=1,nz ; do j=js,je ; do i=is,ie
      work_3d(i,j,k) = Idt * (h(i,j,k) - h_old(i,j,k))
    enddo ; enddo ; enddo
    call post_data(CS%id_internal_heat_h_tendency, work_3d, CS%diag, alt_h=h_old)
  endif

!  do j=js,je ; do i=is,ie
!    resid(i,j) = tv%internal_heat(i,j) - resid(i,j) - GV%H_to_RZ * &amp;
!           (G%mask2dT(i,j) * (CS%geo_heat(i,j) * (dt*Irho_cp)))
!  enddo ; enddo

end subroutine geothermal_entraining

!&gt; Applies geothermal heating to the bottommost layers that occur within GEOTHERMAL_THICKNESS of
!! the bottom, by simply heating the water in place.  Any heat that can not be applied to the ocean
!! is returned (WHERE)?
subroutine geothermal_in_place(h, tv, dt, G, GV, US, CS, halo)
  type(ocean_grid_type),                     intent(inout) :: G  !&lt; The ocean&#39;s grid structure.
  type(verticalGrid_type),                   intent(in)    :: GV !&lt; The ocean&#39;s vertical grid structure.
  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)), intent(in)    :: h  !&lt; Layer thicknesses [H ~&gt; m or kg m-2]
  type(thermo_var_ptrs),                     intent(inout) :: tv !&lt; A structure containing pointers
                                                                 !! to any available thermodynamic fields.
  real,                                      intent(in)    :: dt !&lt; Time increment [T ~&gt; s].
  type(unit_scale_type),                     intent(in)    :: US !&lt; A dimensional unit scaling type
  type(geothermal_CS),                       intent(in)    :: CS !&lt; Geothermal heating control struct
  integer,                         optional, intent(in)    :: halo !&lt; Halo width over which to work

  ! Local variables
  real, dimension(SZI_(G)) :: &amp;
    heat_rem,  &amp; ! remaining heat [H C ~&gt; m degC or kg degC m-2]
    h_geo_rem    ! remaining thickness to apply geothermal heating [H ~&gt; m or kg m-2]

  real :: Angstrom, H_neglect  ! small thicknesses [H ~&gt; m or kg m-2]
  real :: heat_here     ! heating applied to the present layer [C H ~&gt; degC m or degC kg m-2]
  real :: dTemp         ! temperature increase in a layer [C ~&gt; degC]
  real :: Irho_cp       ! inverse of heat capacity per unit layer volume
                        ! [C H Q-1 R-1 Z-1 ~&gt; degC m3 J-1 or degC kg J-1]

  real, dimension(SZI_(G),SZJ_(G),SZK_(GV)) :: &amp;
    dTdt_diag           ! Diagnostic of temperature tendency [C T-1 ~&gt; degC s-1] which might be
                        ! converted into a layer-integrated heat tendency [Q R Z T-1 ~&gt; W m-2]
  real :: Idt           ! inverse of the timestep [T-1 ~&gt; s-1]
  logical :: do_any     ! True if there is more to be done on the current j-row.
  logical :: calc_diags ! True if diagnostic tendencies are needed.
  integer :: i, j, k, is, ie, js, je, nz, isj, iej

  is = G%isc ; ie = G%iec ; js = G%jsc ; je = G%jec ; nz = GV%ke
  if (present(halo)) then
    is = G%isc-halo ; ie = G%iec+halo ; js = G%jsc-halo ; je = G%jec+halo
  endif

  if (.not. CS%initialized) call MOM_error(FATAL, &quot;MOM_geothermal: &quot;//&amp;
         &quot;Module must be initialized before it is used.&quot;)
  if (.not.CS%apply_geothermal) return

  Irho_cp   = 1.0 / (GV%H_to_RZ * tv%C_p)
  Angstrom  = GV%Angstrom_H
  H_neglect = GV%H_subroundoff
  Idt       = 1.0 / dt

  if (.not.associated(tv%T)) call MOM_error(FATAL, &quot;MOM geothermal_in_place: &quot;//&amp;
      &quot;Geothermal heating can only be applied if T &amp; S are state variables.&quot;)

!  do i=is,ie ; do j=js,je
!    resid(i,j) = tv%internal_heat(i,j)
!  enddo ; enddo

  ! Conditionals for tracking diagnostic depdendencies
  calc_diags = (CS%id_internal_heat_heat_tendency &gt; 0) .or. (CS%id_internal_heat_temp_tendency &gt; 0)

  if (calc_diags) dTdt_diag(:,:,:) = 0.0

  !$OMP parallel do default(shared) private(heat_rem,do_any,h_geo_rem,isj,iej,heat_here,dTemp)
  do j=js,je
    ! Only work on columns that are being heated, and heat the near-bottom water.

    ! If there is not enough mass in the ocean, pass some of the heat up
    ! from the ocean via the frazil field?

    do_any = .false.
    do i=is,ie
      heat_rem(i) = G%mask2dT(i,j) * (CS%geo_heat(i,j) * (dt*Irho_cp))
      if (heat_rem(i) &gt; 0.0) do_any = .true.
      h_geo_rem(i) = CS%Geothermal_thick
    enddo
    if (.not.do_any) cycle

    ! Find the first and last columns that need to be worked on.
    isj = ie+1 ; do i=is,ie ; if (heat_rem(i) &gt; 0.0) then ; isj = i ; exit ; endif ; enddo
    iej = is-1 ; do i=ie,is,-1 ; if (heat_rem(i) &gt; 0.0) then ; iej = i ; exit ; endif ; enddo

    do k=nz,1,-1
      do_any = .false.
      do i=isj,iej
        if ((heat_rem(i) &gt; 0.0) .and. (h(i,j,k) &gt; Angstrom)) then
          ! Apply some or all of the remaining heat to this layer.
          ! Convective adjustment occurs outside of this module if necessary.
          if ((h(i,j,k)-Angstrom) &gt;= h_geo_rem(i)) then
            heat_here = heat_rem(i)
            h_geo_rem(i) = 0.0
            heat_rem(i) = 0.0
          else
            heat_here = heat_rem(i) * ((h(i,j,k)-Angstrom) / (h_geo_rem(i) + H_neglect))
            h_geo_rem(i) = h_geo_rem(i) - (h(i,j,k)-Angstrom)
            heat_rem(i) = heat_rem(i) - heat_here
          endif

          dTemp = heat_here / (h(i,j,k) + H_neglect)
          tv%T(i,j,k) = tv%T(i,j,k) + dTemp
          if (calc_diags) dTdt_diag(i,j,k) = dTemp * Idt
        endif

        if (heat_rem(i) &gt; 0.0) do_any= .true.
      enddo

      if (.not.do_any) exit
    enddo ! k-loop

    if (associated(tv%internal_heat)) then ; do i=is,ie
      tv%internal_heat(i,j) = tv%internal_heat(i,j) + GV%H_to_RZ * &amp;
           (G%mask2dT(i,j) * (CS%geo_heat(i,j) * (dt*Irho_cp)) - heat_rem(i))
    enddo ; endif
  enddo ! j-loop

  ! Post diagnostics of 3D tendencies of heat and temperature due to geothermal heat
  if (CS%id_internal_heat_temp_tendency &gt; 0) then
    call post_data(CS%id_internal_heat_temp_tendency, dTdt_diag, CS%diag, alt_h=h)
  endif
  if (CS%id_internal_heat_heat_tendency &gt; 0) then
    do k=1,nz ; do j=js,je ; do i=is,ie
      ! Dangerously reuse dTdt_diag for a related variable with different units, going from
      ! units of [C T-1 ~&gt; degC s-1] to units of [Q R Z T-1 ~&gt; W m-2]
      dTdt_diag(i,j,k) = (GV%H_to_RZ*tv%C_p) * (h(i,j,k) * dTdt_diag(i,j,k))
    enddo ; enddo ; enddo
    call post_data(CS%id_internal_heat_heat_tendency, dTdt_diag, CS%diag, alt_h=h)
  endif

!  do j=js,je ; do i=is,ie
!    resid(i,j) = tv%internal_heat(i,j) - resid(i,j) - GV%H_to_RZ * &amp;
!           (G%mask2dT(i,j) * (CS%geo_heat(i,j) * (dt*Irho_cp)))
!  enddo ; enddo

end subroutine geothermal_in_place

!&gt; Initialize parameters and allocate memory associated with the geothermal heating module.
subroutine geothermal_init(Time, G, GV, US, param_file, diag, CS, useALEalgorithm)
  type(time_type), target, intent(in)    :: Time !&lt; Current model time.
  type(ocean_grid_type),   intent(inout) :: G    !&lt; The ocean&#39;s grid structure.
  type(verticalGrid_type), intent(in)    :: GV   !&lt; The ocean&#39;s vertical grid structure.
  type(unit_scale_type),   intent(in)    :: US   !&lt; A dimensional unit scaling type
  type(param_file_type),   intent(in)    :: param_file !&lt; A structure to parse for run-time
                                                 !! parameters.
  type(diag_ctrl), target, intent(inout) :: diag !&lt; Structure used to regulate diagnostic output.
  type(geothermal_CS),     intent(inout) :: CS   !&lt; Geothermal heating control struct
  logical,       optional, intent(in)    :: useALEalgorithm  !&lt; logical for whether to use ALE remapping

! This include declares and sets the variable &quot;version&quot;.
#include &quot;version_variable.h&quot;
  character(len=40)  :: mdl = &quot;MOM_geothermal&quot;  ! module name
  character(len=48)  :: thickness_units
  ! Local variables
  character(len=200) :: inputdir, geo_file, filename, geotherm_var
  real :: geo_scale  ! A constant heat flux or dimensionally rescaled geothermal flux scaling factor
                     ! [Q R Z T-1 ~&gt; W m-2] or [Q R Z m2 s J-1 T-1 ~&gt; nondim]
  integer :: i, j, isd, ied, jsd, jed, id
  isd = G%isd ; ied = G%ied ; jsd = G%jsd ; jed = G%jed

  CS%initialized = .true.
  CS%diag =&gt; diag
  CS%Time =&gt; Time

  ! write parameters to the model log.
  call log_version(param_file, mdl, version, &quot;&quot;)
  call get_param(param_file, mdl, &quot;GEOTHERMAL_SCALE&quot;, geo_scale, &amp;
                 &quot;The constant geothermal heat flux, a rescaling &quot;//&amp;
                 &quot;factor for the heat flux read from GEOTHERMAL_FILE, or &quot;//&amp;
                 &quot;0 to disable the geothermal heating.&quot;, &amp;
                 units=&quot;W m-2 or various&quot;, default=0.0, scale=US%W_m2_to_QRZ_T)
  CS%apply_geothermal = .not.(geo_scale == 0.0)
  if (.not.CS%apply_geothermal) return

  call safe_alloc_alloc(CS%geo_heat, isd, ied, jsd, jed) ; CS%geo_heat(:,:) = 0.0

  call get_param(param_file, mdl, &quot;GEOTHERMAL_FILE&quot;, geo_file, &amp;
                 &quot;The file from which the geothermal heating is to be &quot;//&amp;
                 &quot;read, or blank to use a constant heating rate.&quot;, default=&quot; &quot;)
  call get_param(param_file, mdl, &quot;GEOTHERMAL_THICKNESS&quot;, CS%geothermal_thick, &amp;
                 &quot;The thickness over which to apply geothermal heating.&quot;, &amp;
                 units=&quot;m&quot;, default=0.1, scale=GV%m_to_H)
  call get_param(param_file, mdl, &quot;GEOTHERMAL_DRHO_DT_INPLACE&quot;, CS%dRcv_dT_inplace, &amp;
                 &quot;The value of drho_dT above which geothermal heating &quot;//&amp;
                 &quot;simply heats water in place instead of moving it between &quot;//&amp;
                 &quot;isopycnal layers.  This must be negative.&quot;, &amp;
                 units=&quot;kg m-3 K-1&quot;, scale=US%kg_m3_to_R*US%C_to_degC, default=-0.01, &amp;
                 do_not_log=((GV%nk_rho_varies&lt;=0).or.(GV%nk_rho_varies&gt;=GV%ke)) )
  if (CS%dRcv_dT_inplace &gt;= 0.0) call MOM_error(FATAL, &quot;geothermal_init: &quot;//&amp;
         &quot;GEOTHERMAL_DRHO_DT_INPLACE must be negative.&quot;)

  if (len_trim(geo_file) &gt;= 1) then
    call get_param(param_file, mdl, &quot;INPUTDIR&quot;, inputdir, default=&quot;.&quot;)
    inputdir = slasher(inputdir)
    filename = trim(inputdir)//trim(geo_file)
    call log_param(param_file, mdl, &quot;INPUTDIR/GEOTHERMAL_FILE&quot;, filename)
    call get_param(param_file, mdl, &quot;GEOTHERMAL_VARNAME&quot;, geotherm_var, &amp;
                 &quot;The name of the geothermal heating variable in GEOTHERMAL_FILE.&quot;, &amp;
                 default=&quot;geo_heat&quot;)
    call MOM_read_data(filename, trim(geotherm_var), CS%geo_heat, G%Domain)
    do j=jsd,jed ; do i=isd,ied
      CS%geo_heat(i,j) = (G%mask2dT(i,j) * geo_scale) * CS%geo_heat(i,j)
    enddo ; enddo
  else
    do j=jsd,jed ; do i=isd,ied
      CS%geo_heat(i,j) = G%mask2dT(i,j) * geo_scale
    enddo ; enddo
  endif
  call pass_var(CS%geo_heat, G%domain)

  thickness_units = get_thickness_units(GV)

  ! post the static geothermal heating field
  id = register_static_field(&#39;ocean_model&#39;, &#39;geo_heat&#39;, diag%axesT1,   &amp;
        &#39;Geothermal heat flux into ocean&#39;, &#39;W m-2&#39;, conversion=US%QRZ_T_to_W_m2, &amp;
        cmor_field_name=&#39;hfgeou&#39;, &amp;
        cmor_standard_name=&#39;upward_geothermal_heat_flux_at_sea_floor&#39;, &amp;
        cmor_long_name=&#39;Upward geothermal heat flux at sea floor&#39;, &amp;
        x_cell_method=&#39;mean&#39;, y_cell_method=&#39;mean&#39;, area_cell_method=&#39;mean&#39;)
  if (id &gt; 0) call post_data(id, CS%geo_heat, diag, .true.)

  ! Diagnostic for tendencies due to internal heat (in 3d)
  CS%id_internal_heat_heat_tendency=register_diag_field(&#39;ocean_model&#39;, &amp;
        &#39;internal_heat_heat_tendency&#39;, diag%axesTL, Time,              &amp;
        &#39;Heat tendency (in 3D) due to internal (geothermal) sources&#39;,  &amp;
        &#39;W m-2&#39;, conversion=US%QRZ_T_to_W_m2, v_extensive=.true.)
  CS%id_internal_heat_temp_tendency=register_diag_field(&#39;ocean_model&#39;, &amp;
        &#39;internal_heat_temp_tendency&#39;, diag%axesTL, Time,              &amp;
        &#39;Temperature tendency (in 3D) due to internal (geothermal) sources&#39;, &amp;
        &#39;degC s-1&#39;, conversion=US%C_to_degC*US%s_to_T, v_extensive=.true.)
  if (.not.useALEalgorithm) then
    ! Do not offer this diagnostic if heating will be in place.
    CS%id_internal_heat_h_tendency=register_diag_field(&#39;ocean_model&#39;,    &amp;
        &#39;internal_heat_h_tendency&#39;, diag%axesTL, Time,                &amp;
        &#39;Thickness tendency (in 3D) due to internal (geothermal) sources&#39;, &amp;
        trim(thickness_units)//&#39; s-1&#39;, conversion=GV%H_to_MKS*US%s_to_T, v_extensive=.true.)
  endif

end subroutine geothermal_init

!&gt; Clean up and deallocate memory associated with the geothermal heating module.
subroutine geothermal_end(CS)
  type(geothermal_CS), intent(inout) :: CS !&lt; Geothermal heating control struct
  if (allocated(CS%geo_heat)) deallocate(CS%geo_heat)
end subroutine geothermal_end

!&gt; \namespace mom_geothermal
!!
!! Geothermal heating can be added either in a layered isopycnal mode, in which the heating raises the density
!! of the layer to the target density of the layer above, and then moves the water into that layer, or in a
!! simple Eulerian mode, in which the bottommost GEOTHERMAL_THICKNESS are heated.  Geothermal heating will also
!! provide a buoyant source of bottom TKE that can be used to further mix the near-bottom water. In cold fresh
!! water lakes where heating increases density, water should be moved into deeper layers, but this is not
!! implemented yet.

end module MOM_geothermal
</code></pre>
<ul>
<li>One module per file</li>
<li>Module communication by <strong>control structures</strong></li>
<li>No internal module variables (i.e. no "state")</li>
</ul>
<aside class="notes">
<p>One consequence of having no state is that functions have many, many arguments. An object-oriented approach could help reduce this.</p>
</aside>
</section>

<section id="main-loop" class="title-slide slide level1">
<h1>Main Loop</h1>
<p><code>step_MOM()</code></p>
<table>
<thead>
<tr class="header">
<th>Process</th>
<th>Subroutine</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Dynamics</td>
<td><code>step_MOM_dynamics()</code></td>
</tr>
<tr class="even">
<td>Thermodynamics</td>
<td><code>step_MOM_thermo()</code></td>
</tr>
<tr class="odd">
<td>Tracers</td>
<td><code>step_MOM_tracer_dyn()</code></td>
</tr>
</tbody>
</table>
<p>Ordering is somewhat configurable</p>
</section>

<section id="outer-dynamic-core" class="title-slide slide level1">
<h1>"Outer" Dynamic core</h1>
<p><code>step_MOM_dynamics()</code></p>
<table>
<thead>
<tr class="header">
<th>Process</th>
<th>Subroutine</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Thickness Diffusion</td>
<td><code>thickness_diffuse()</code></td>
</tr>
<tr class="even">
<td>Bottom drag</td>
<td><code>set_viscous_BBL()</code></td>
</tr>
<tr class="odd">
<td>Flow transport</td>
<td><code>step_MOM_dyn_split_RK2()</code></td>
</tr>
<tr class="even">
<td>ML restratification</td>
<td><code>mixedlayer_restrat()</code></td>
</tr>
<tr class="odd">
<td>Mesoscale eddies</td>
<td><code>step_forward_MEKE()</code></td>
</tr>
</tbody>
</table>
<aside class="notes">
<p>Most ocean-specific parameterizations appear here</p>
</aside>
</section>

<section id="inner-dynamic-core" class="title-slide slide level1">
<h1>"Inner" Dynamic Core</h1>
<p><code>step_MOM_dyn_split_RK2()</code></p>
<table>
<thead>
<tr class="header">
<th>Process</th>
<th>Subroutine</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(f \hat{z} \times \mathbf{u}\)</span></td>
<td><code>CorAdCalc()</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(-\nabla p\)</span></td>
<td><code>PressureForce()</code></td>
</tr>
<tr class="odd">
<td>Vertical Viscosity</td>
<td><code>vertvisc()</code></td>
</tr>
<tr class="even">
<td>Barotropic steps</td>
<td><code>btstep()</code></td>
</tr>
<tr class="odd">
<td>Mass/Volume Balance</td>
<td><code>continuity()</code></td>
</tr>
<tr class="even">
<td>Horizontal viscosity</td>
<td><code>horizontal_viscosity()</code></td>
</tr>
</tbody>
</table>
<aside class="notes">
<p>Note that this repeats in a predictor/corrector-like algorithm.</p>
</aside>
</section>

<section id="thermodynamics" class="title-slide slide level1">
<h1>Thermodynamics</h1>
<table>
<thead>
<tr class="header">
<th>Process</th>
<th>Subroutine</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>diabatic</td>
<td>???</td>
</tr>
<tr class="even">
<td>adiabatic</td>
<td>???</td>
</tr>
<tr class="odd">
<td>ALE_main</td>
<td>???</td>
</tr>
<tr class="even">
<td>diag_update_remap_grids</td>
<td>???</td>
</tr>
</tbody>
</table>
</section>

<section id="tracers" class="title-slide slide level1">
<h1>Tracers</h1>
<ul>
<li>advect_tracer</li>
<li>tracer_hordiff</li>
<li>update_segment_tracer_reservoirs</li>
<li>step_forward_meke</li>
</ul>
</section>

<section id="metrics" class="title-slide slide level1">
<h1>Metrics</h1>
<p><img data-src="img/Arakawa_C_grid.png" alt="image" /></p>
<p><span class="math inline">\((i,j)\)</span> follows the "northeast convention"</p>
</section>

<section id="index-macros" class="title-slide slide level1">
<h1>Index Macros</h1>
<p>Static memory is supported with macros</p>
<p><code>#include &lt;MOM_memory.h&gt;</code></p>
<table>
<thead>
<tr class="header">
<th>Field</th>
<th>Declaration</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Center</td>
<td><code>h(SZI_(G), SZJ_(G), SZK_(G))</code></td>
</tr>
<tr class="even">
<td>East Face</td>
<td><code>u(SZIB_(G), SZJ_(G), SZK_(G))</code></td>
</tr>
<tr class="odd">
<td>North Face</td>
<td><code>v(SZI_(G), SZJB_(G), SZK_(G))</code></td>
</tr>
<tr class="even">
<td>Vertex</td>
<td><code>q(SZIB_(G), SZJB_(G), SZK_(G))</code></td>
</tr>
</tbody>
</table>
<p>Use <code>ALLOCABLE_()</code> to allocate (if static)</p>
</section>

<section id="memory-layout" class="title-slide slide level1">
<h1>Memory Layout</h1>
<table>
<tbody>
<tr class="odd">
<td><p>Symmetric:</p>
<figure>
<img data-src="img/Horizontal_NE_indexing_sym.png" />
</figure></td>
<td><p>Nonsymmetric:</p>
<figure>
<img data-src="img/Horizontal_NE_indexing_nonsym.png" />
</figure></td>
</tr>
</tbody>
</table>
<p>Symmetric grids have additional west/south points</p>
<aside class="notes">
<p>If periodic, they match the east/north points</p>
</aside>
</section>

<section id="parallelization" class="title-slide slide level1">
<h1>Parallelization</h1>
<p><img data-src="img/halo.svg" alt="image" /></p>
<p>MOM is single-pass: 4 sides and 4 corners concurrently</p>
<p>(Other models are two-pass: N/S then E/W)</p>
</section>

<section id="stencil-domains" class="title-slide slide level1">
<h1>Stencil Domains</h1>
<table>
<tbody>
<tr class="odd">
<td><img data-src="img/Horizontal_NE_indexing_sym.png" alt="image" /></td>
<td><dl>
<dt>Compute Domain</dt>
<dd><p>Physical values</p>
</dd>
<dt>Data Domain</dt>
<dd><p>Include halos</p>
</dd>
<dt>Global Domain</dt>
<dd><p>Global indexing</p>
</dd>
</dl></td>
</tr>
</tbody>
</table>
</section>

<section>
<section id="message-passing" class="title-slide slide level1">
<h1>Message Passing</h1>
<dl>
<dt><code>create_group_pass(group, array, domain)</code></dt>
<dd><p>Create a "group pass" for an array</p>
</dd>
<dt><code>do_group_pass(group, domain)</code></dt>
<dd><p>Immediately update the halo ("blocking")</p>
</dd>
<dt><code>start_group_pass(group, domain)</code></dt>
<dd><p>Begin a halo update ("nonblocking")</p>
</dd>
<dt><code>complete_group_pass(group, domain)</code></dt>
<dd><p>Wait until a halo update has completed</p>
</dd>
</dl>
</section>
<section id="example-halo-update" class="slide level2">
<h2>Example halo update</h2>
<pre class="fortran"><code>call create_group_pass(CS%pass_uv, u, v, G%Domain, &amp;
                       halo=max(2,cont_stencil))

! Update u and v

if (G%nonblocking_updates) &amp;
   call start_group_pass(CS%pass_uv, G%Domain, clock=id_clock_pass)

! Do some work unrelated to u and v

if (G%nonblocking_updates) then
  call complete_group_pass(CS%pass_uv, G%Domain, clock=id_clock_pass)
else
  call do_group_pass(CS%pass_uv, G%Domain, clock=id_clock_pass)
endif</code></pre>
</section></section>
<section id="masking" class="title-slide slide level1">
<h1>Masking</h1>
<p>TODO</p>
</section>

<section id="diagnostics" class="title-slide slide level1">
<h1>Diagnostics</h1>
<p><code>register_diag_field()</code></p>
<pre class="fortran"><code>CS%id_Kh_h = register_diag_field(&#39;ocean_model&#39;, &#39;Khh&#39;, &amp;
   diag%axesTL, Time, &amp;
   &#39;Laplacian Horizontal Viscosity at h Points&#39;, &amp;
   &#39;m2 s-1&#39;, &amp;
   conversion=(US%L_to_m**2)*US%s_to_T)</code></pre>
<p><code>post_data()</code></p>
<pre class="fortran"><code>if (CS%id_Kh_h &gt; 0) call post_data(CS%id_Kh_h, Kh_h, CS%diag)</code></pre>
</section>

<section id="input-parameters" class="title-slide slide level1">
<h1>Input Parameters</h1>
<p>Define <code>MOM_input</code> parameters with <code>get_param()</code>:</p>
<pre class="fortran"><code>call get_param(param_file, mdl, &quot;KH&quot;, Kh, &amp;
               &quot;The background Laplacian horizontal viscosity&quot;, &amp;
               units=&quot;m2 s-1&quot;, &amp;
               default=0.0, &amp;
               scale=(US%m_to_L**2)*US%T_to_s, &amp;
               do_not_log=.not.CS%Laplacian &amp;
)</code></pre>
</section>

<section>
<section id="checksums" class="title-slide slide level1">
<h1>Checksums</h1>
<p>Verify the reproducibility of fields:</p>
<table>
<thead>
<tr class="header">
<th>Field position</th>
<th>Checksum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Center</td>
<td><code>hchksum</code></td>
</tr>
<tr class="even">
<td>Face</td>
<td><code>uvchksum</code></td>
</tr>
<tr class="odd">
<td>Vertex</td>
<td><code>Bchksum</code></td>
</tr>
</tbody>
</table>
<pre class="fortran"><code>call hchksum(Kh_h, &quot;Kh_h&quot;, G%HI, scale=(US%L_to_m**2)*US%s_to_T)
call uvchksum(&quot;Kh_[uv]&quot;, Kh_u, Kh_v, G%HI, &amp;
              scale=(US%L_to_m**2)*US%s_to_T, scalar_pair=.true.)
call Bchksum(Kh_q, &quot;Kh_q&quot;, G%HI, scale=(US%L_to_m**2)*US%s_to_T)</code></pre>
</section>
<section id="sample-debug-output" class="slide level2">
<h2>Sample debug output</h2>
<p>TODO</p>
</section></section>
<section id="timers" class="title-slide slide level1">
<h1>Timers</h1>

</section>
    </div>
  </div>

  <script src="./reveal.js/dist/reveal.js"></script>
  <script src="./reveal.js/plugin/math/math.js"></script>
  <script src="./reveal.js/plugin/notes/notes.js"></script>
  <script src="./reveal.js/plugin/highlight/highlight.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display the page number of the current slide
        slideNumber: true,
        // Push each slide change to the browser history
        history: true,
        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js',
          config: 'TeX-AMS_HTML-full',
          //TeX: {
          //  inlineMath: [['\\(','\\)']],
          //  displayMath: [['\\[','\\]']],
          //  balanceBraces: true,
          //  processEscapes: false,
          //  processRefs: true,
          //  processEnvironments: true,
          //  preview: 'TeX',
          //  skipTags: ['script','noscript','style','textarea','pre','code'],
          //  ignoreClass: 'tex2jax_ignore',
          //  processClass: 'tex2jax_process'
          //},
        },

        // Optional reveal.js plugins
        dependencies: [
          { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: './reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: './reveal.js/plugin/notes/notes.js', async: true }
        ],
        plugins : [ RevealMath, RevealNotes, RevealHighlight],
      });
    </script>
    </body>
</html>
